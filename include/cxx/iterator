#ifndef CAPRESE_LIBC_CXX_ITERATOR_
#define CAPRESE_LIBC_CXX_ITERATOR_

#include <cassert>
#include <cstddef>
#include <type_traits>

namespace std {
  struct input_iterator_tag { };

  struct output_iterator_tag { };

  struct forward_iterator_tag: public input_iterator_tag { };

  struct bidirectional_iterator_tag: public forward_iterator_tag { };

  struct random_access_iterator_tag: public bidirectional_iterator_tag { };

  struct contiguous_iterator_tag: public random_access_iterator_tag { };

  template<class Category, class T, class Distance = ptrdiff_t, class Pointer = T*, class Reference = T&>
  struct iterator {
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = Pointer;
    using reference         = Reference;
    using iterator_category = Category;
  };

  template<class I>
  struct iterator_traits {
    using difference_type   = typename I::difference_type;
    using value_type        = typename I::value_type;
    using pointer           = typename I::pointer;
    using reference         = typename I::reference;
    using iterator_category = typename I::iterator_category;
  };

  template<class T>
  struct iterator_traits<T*> {
    using difference_type   = ptrdiff_t;
    using value_type        = remove_cv_t<T>;
    using pointer           = T*;
    using reference         = T&;
    using iterator_category = random_access_iterator_tag;
  };

  template<typename I>
  class reverse_iterator: public iterator<typename iterator_traits<I>::iterator_category,
                                          typename iterator_traits<I>::value_type,
                                          typename iterator_traits<I>::difference_type,
                                          typename iterator_traits<I>::pointer,
                                          typename iterator_traits<I>::reference> {
  public:
    using difference_type   = typename iterator_traits<I>::difference_type;
    using value_type        = typename iterator_traits<I>::value_type;
    using pointer           = typename iterator_traits<I>::pointer;
    using reference         = typename iterator_traits<I>::reference;
    using iterator_type     = I;
    using iterator_category = typename iterator_traits<I>::iterator_category;

  protected:
    I current;

  public:
    constexpr reverse_iterator(): current(I {}) { }

    constexpr explicit reverse_iterator(I x): current(x) { }

    ~reverse_iterator() = default;

    constexpr reverse_iterator& operator=(const reverse_iterator& u) = default;

    constexpr I base() const {
      return current;
    }

    constexpr reference operator*() const {
      I tmp = current;
      return *--tmp;
    }

    constexpr pointer operator->() const {
      return &(operator*());
    }

    constexpr reverse_iterator& operator++() {
      --current;
      return *this;
    }

    constexpr reverse_iterator operator++([[maybe_unused]] int) {
      reverse_iterator tmp = *this;
      --current;
      return tmp;
    }

    constexpr reverse_iterator& operator--() {
      ++current;
      return *this;
    }

    constexpr reverse_iterator& operator--([[maybe_unused]] int) {
      reverse_iterator tmp = *this;
      ++current;
      return tmp;
    }

    constexpr reverse_iterator operator+(difference_type n) const {
      return reverse_iterator(current - n);
    }

    constexpr reverse_iterator& operator+=(difference_type n) {
      current -= n;
      return *this;
    }

    constexpr reverse_iterator operator-(difference_type n) const {
      return reverse_iterator(current + n);
    }

    constexpr reverse_iterator& operator-=(difference_type n) {
      current += n;
      return *this;
    }

    constexpr reference operator[](difference_type n) const {
      return current[-n - 1];
    }
  };

  template<typename L, typename R>
  constexpr bool operator==(const reverse_iterator<L>& lhs, const reverse_iterator<R>& rhs) {
    return lhs.base() == rhs.base();
  }

  template<typename L, typename R>
  constexpr bool operator!=(const reverse_iterator<L>& lhs, const reverse_iterator<R>& rhs) {
    return lhs.base() != rhs.base();
  }

  template<typename L, typename R>
  constexpr bool operator<(const reverse_iterator<L>& lhs, const reverse_iterator<R>& rhs) {
    return lhs.base() < rhs.base();
  }

  template<typename L, typename R>
  constexpr bool operator<=(const reverse_iterator<L>& lhs, const reverse_iterator<R>& rhs) {
    return lhs.base() <= rhs.base();
  }

  template<typename L, typename R>
  constexpr bool operator>(const reverse_iterator<L>& lhs, const reverse_iterator<R>& rhs) {
    return lhs.base() > rhs.base();
  }

  template<typename L, typename R>
  constexpr bool operator>=(const reverse_iterator<L>& lhs, const reverse_iterator<R>& rhs) {
    return lhs.base() >= rhs.base();
  }

  template<class L, class R>
  constexpr auto operator-(const reverse_iterator<L>& lhs, const reverse_iterator<R>& rhs) -> decltype(lhs.base() - rhs.base()) {
    return lhs.base() - rhs.base();
  }

  template<typename I>
  constexpr reverse_iterator<I> operator+(typename reverse_iterator<I>::difference_type n, const reverse_iterator<I>& it) {
    return reverse_iterator<I>(it.base() - n);
  }

  template<typename T>
  constexpr auto begin(T& value) -> decltype(value.begin()) {
    return value.begin();
  }

  template<typename T>
  constexpr auto begin(const T& value) -> decltype(value.begin()) {
    return value.begin();
  }

  template<typename T, size_t N>
  constexpr T* begin(T (&array)[N]) noexcept {
    return array;
  }

  template<typename T>
  constexpr auto end(T& value) -> decltype(value.end()) {
    return value.end();
  }

  template<typename T>
  constexpr auto end(const T& value) -> decltype(value.end()) {
    return value.end();
  }

  template<typename T, size_t N>
  constexpr T* end(const T (&array)[N]) noexcept {
    return array + N;
  }

  template<typename T>
  auto rbegin(T& value) -> decltype(value.rbegin()) {
    return value.rbegin();
  }

  template<typename T>
  auto rbegin(const T& value) -> decltype(value.rbegin()) {
    return value.rbegin();
  }

  template<typename T, size_t N>
  constexpr reverse_iterator<T*> rbegin(T (&array)[N]) {
    return reverse_iterator<T*>(array + N);
  }

  template<typename T>
  auto rend(T& value) -> decltype(value.rend()) {
    return value.rend();
  }

  template<typename T>
  auto rend(const T& value) -> decltype(value.rend()) {
    return value.rend();
  }

  template<typename T, size_t N>
  constexpr reverse_iterator<T*> rend(T (&array)[N]) {
    return reverse_iterator<T*>(array);
  }

  template<typename InputIterator>
  constexpr typename iterator_traits<InputIterator>::difference_type __distance(InputIterator first, InputIterator last, [[maybe_unused]] input_iterator_tag) {
    typename iterator_traits<InputIterator>::difference_type n = 0;
    while (first != last) {
      ++first;
      ++n;
    }
    return n;
  }

  template<typename RandomAccessIterator>
  constexpr typename iterator_traits<RandomAccessIterator>::difference_type __distance(RandomAccessIterator first, RandomAccessIterator last, [[maybe_unused]] random_access_iterator_tag) {
    return last - first;
  }

  template<typename InputIterator>
  constexpr typename iterator_traits<InputIterator>::difference_type distance(InputIterator first, InputIterator last) {
    using category = typename iterator_traits<InputIterator>::iterator_category;
    return __distance(first, last, category {});
  }

  template<typename InputIterator, typename Distance>
  constexpr void __advance(InputIterator& iter, Distance n, [[maybe_unused]] input_iterator_tag) {
    assert(n >= 0);

    while (n--) {
      ++iter;
    }
  }

  template<typename BidirectionalIterator, typename Distance>
  constexpr void __advance(BidirectionalIterator iter, Distance n, [[maybe_unused]] bidirectional_iterator_tag) {
    if (n > 0) {
      while (n--) {
        ++iter;
      }
    } else {
      while (n++) {
        --iter;
      }
    }
  }

  template<typename RandomAccessIterator, typename Distance>
  constexpr void __advance(RandomAccessIterator& iter, Distance n, [[maybe_unused]] random_access_iterator_tag) {
    iter += n;
  }

  template<typename InputIterator, typename Distance>
  constexpr void advance(InputIterator& iter, Distance n) {
    using category = typename iterator_traits<InputIterator>::iterator_category;
    __advance(iter, n, category {});
  }
} // namespace std

#endif // CAPRESE_LIBC_CXX_ITERATOR_
